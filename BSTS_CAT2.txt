
VERTICAL TRAVERSAL
import java.util.*;

// TreeNode class representing each node in the binary tree
class TreeNode {
    int val;
    TreeNode left, right;

    TreeNode(int val) {
        this.val = val;
        left = right = null;
    }
}

// Class representing vertical order traversal
class VerticalOrderTraversal {
    // Helper class to store node and its horizontal distance from root
    static class Pair {
        TreeNode node;
        int hd; // Horizontal distance

        Pair(TreeNode node, int hd) {
            this.node = node;
            this.hd = hd;
        }
    }

    // Function to perform vertical order traversal
    public static void verticalOrderTraversal(TreeNode root) {
        if (root == null)
            return;

        // TreeMap to store nodes at each horizontal distance
        TreeMap<Integer, List<Integer>> map = new TreeMap<>();
        Queue<Pair> queue = new LinkedList<>();
        queue.offer(new Pair(root, 0)); // Root has horizontal distance 0

        // Perform level order traversal
        while (!queue.isEmpty()) {
            Pair pair = queue.poll();
            TreeNode node = pair.node;
            int hd = pair.hd;

            // Add node value to corresponding horizontal distance list in the map
            if (!map.containsKey(hd)) {
                map.put(hd, new ArrayList<>());
            }
            map.get(hd).add(node.val);

            // Enqueue left and right children with corresponding horizontal distances
            if (node.left != null)
                queue.offer(new Pair(node.left, hd - 1));
            if (node.right != null)
                queue.offer(new Pair(node.right, hd + 1));
        }

        // Print nodes for each horizontal distance
        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {
            System.out.print("Vertical distance " + entry.getKey() + ": ");
            for (int val : entry.getValue()) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
    }

    // Function to build binary tree from user input
    public static TreeNode buildTree() {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the root value: ");
        int rootValue = scanner.nextInt();
        TreeNode root = new TreeNode(rootValue);

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode current = queue.poll();
            System.out.print("Enter left child value for " + current.val + " (or -1 if none): ");
            int leftValue = scanner.nextInt();
            if (leftValue != -1) {
                current.left = new TreeNode(leftValue);
                queue.offer(current.left);
            }
            System.out.print("Enter right child value for " + current.val + " (or -1 if none): ");
            int rightValue = scanner.nextInt();
            if (rightValue != -1) {
                current.right = new TreeNode(rightValue);
                queue.offer(current.right);
            }
        }

        scanner.close();
        return root;
    }

    public static void main(String[] args) {
        TreeNode root = buildTree();
        System.out.println("\nVertical Order Traversal:");
        verticalOrderTraversal(root);
    }
}

Sample Input:
Enter the root value: 1
Enter left child value for 1 (or -1 if none): 2
Enter right child value for 1 (or -1 if none): 3
Enter left child value for 2 (or -1 if none): 4
Enter right child value for 2 (or -1 if none): 5
Enter left child value for 3 (or -1 if none): -1
Enter right child value for 3 (or -1 if none): 6
Enter left child value for 4 (or -1 if none): -1
Enter right child value for 4 (or -1 if none): -1
Enter left child value for 5 (or -1 if none): -1
Enter right child value for 5 (or -1 if none): -1
Enter left child value for 6 (or -1 if none): -1
Enter right child value for 6 (or -1 if none): -1
BOUNDARY TRAVERSAL
import java.util.*;

// TreeNode class representing each node in the binary tree
class TreeNode {
    int val;
    TreeNode left, right;

    TreeNode(int val) {
        this.val = val;
        left = right = null;
    }
}

// Class representing boundary traversal
class BoundaryTraversal {
    // Function to perform boundary traversal
    public static void boundaryTraversal(TreeNode root) {
        if (root == null)
            return;

        System.out.print(root.val + " ");

        printLeftBoundary(root.left);
        printLeaves(root.left);
        printLeaves(root.right);
        printRightBoundary(root.right);
    }

    // Function to print the left boundary of the tree (excluding leaves)
    private static void printLeftBoundary(TreeNode root) {
        if (root == null || (root.left == null && root.right == null))
            return;

        System.out.print(root.val + " ");

        if (root.left != null)
            printLeftBoundary(root.left);
        else
            printLeftBoundary(root.right);
    }

    // Function to print the leaves of the tree
    private static void printLeaves(TreeNode root) {
        if (root == null)
            return;

        printLeaves(root.left);

        if (root.left == null && root.right == null)
            System.out.print(root.val + " ");

        printLeaves(root.right);
    }

    // Function to print the right boundary of the tree (excluding leaves)
    private static void printRightBoundary(TreeNode root) {
        if (root == null || (root.left == null && root.right == null))
            return;

        if (root.right != null)
            printRightBoundary(root.right);
        else
            printRightBoundary(root.left);

        System.out.print(root.val + " ");
    }

    // Function to build binary tree from user input
    public static TreeNode buildTree() {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the root value: ");
        int rootValue = scanner.nextInt();
        TreeNode root = new TreeNode(rootValue);

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode current = queue.poll();
            System.out.print("Enter left child value for " + current.val + " (or -1 if none): ");
            int leftValue = scanner.nextInt();
            if (leftValue != -1) {
                current.left = new TreeNode(leftValue);
                queue.offer(current.left);
            }
            System.out.print("Enter right child value for " + current.val + " (or -1 if none): ");
            int rightValue = scanner.nextInt();
            if (rightValue != -1) {
                current.right = new TreeNode(rightValue);
                queue.offer(current.right);
            }
        }

        scanner.close();
        return root;
    }

    public static void main(String[] args) {
        TreeNode root = buildTree();
        System.out.println("\nBoundary Traversal:");
        boundaryTraversal(root);
    }
}
Sample input:
Enter the root value: 1
Enter left child value for 1 (or -1 if none): 2
Enter right child value for 1 (or -1 if none): 3
Enter left child value for 2 (or -1 if none): 4
Enter right child value for 2 (or -1 if none): 5
Enter left child value for 3 (or -1 if none): -1
Enter right child value for 3 (or -1 if none): 6
Enter left child value for 4 (or -1 if none): -1
Enter right child value for 4 (or -1 if none): -1
Enter left child value for 5 (or -1 if none): -1
Enter right child value for 5 (or -1 if none): -1
Enter left child value for 6 (or -1 if none): -1
Enter right child value for 6 (or -1 if none): -1






HEAP SORT

import java.util.*;

class HeapSort {
    // Function to perform heap sort
    public static void heapSort(int[] arr) {
        int n = arr.length;

        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }

        // Extract elements from heap one by one
        for (int i = n - 1; i > 0; i--) {
            // Swap root with current last node
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // Call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }

    // Function to heapify a subtree rooted at index i
    public static void heapify(int[] arr, int n, int i) {
        int largest = i; // Initialize largest as root
        int left = 2 * i + 1; // Left child
        int right = 2 * i + 2; // Right child

        // If left child is larger than root
        if (left < n && arr[left] > arr[largest])
            largest = left;

        // If right child is larger than largest so far
        if (right < n && arr[right] > arr[largest])
            largest = right;

        // If largest is not root
        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;

            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest);
        }
    }

    // Function to print array
    public static void printArray(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the number of elements: ");
        int n = scanner.nextInt();
        int[] arr = new int[n];
        System.out.println("Enter the elements:");

        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        System.out.println("Original array:");
        printArray(arr);

        heapSort(arr);

        System.out.println("Sorted array:");
        printArray(arr);

        scanner.close();
    }
}
Sample Input:
Enter the number of elements: 7
Enter the elements:
12
11
13
5
6
7
1

K-ARY HEAP
import java.util.*;

class KaryHeap {
    private int[] heap;
    private int size;
    private int k;

    public KaryHeap(int capacity, int k) {
        heap = new int[capacity];
        size = 0;
        this.k = k;
    }

    public void insert(int value) {
        if (size == heap.length) {
            System.out.println("Heap is full. Cannot insert more elements.");
            return;
        }

        heap[size++] = value;
        heapifyUp(size - 1);
    }

    private void heapifyUp(int index) {
        int parent = (index - 1) / k;

        while (index > 0 && heap[index] > heap[parent]) {
            swap(index, parent);
            index = parent;
            parent = (index - 1) / k;
        }
    }

    public int extractMax() {
        if (size == 0) {
            throw new IllegalStateException("Heap is empty. Cannot extract max.");
        }

        int root = heap[0];
        heap[0] = heap[size - 1];
        size--;
        heapifyDown(0);
        return root;
    }

    private void heapifyDown(int index) {
        int maxChildIndex = maxChildIndex(index);
        while (maxChildIndex != -1 && heap[index] < heap[maxChildIndex]) {
            swap(index, maxChildIndex);
            index = maxChildIndex;
            maxChildIndex = maxChildIndex(index);
        }
    }

    private int maxChildIndex(int index) {
        int startChild = k * index + 1;
        int endChild = Math.min(startChild + k, size);
        if (startChild >= size) {
            return -1;
        }

        int maxChildIndex = startChild;
        for (int i = startChild + 1; i < endChild; i++) {
            if (heap[i] > heap[maxChildIndex]) {
                maxChildIndex = i;
            }
        }
        return maxChildIndex;
    }

    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }

    public void printHeap() {
        for (int i = 0; i < size; i++) {
            System.out.print(heap[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the capacity of the heap: ");
        int capacity = scanner.nextInt();
        System.out.print("Enter the value of k for K-ary heap: ");
        int k = scanner.nextInt();

        KaryHeap karyHeap = new KaryHeap(capacity, k);

        System.out.println("Enter elements to insert into the K-ary heap (enter -1 to stop):");
        int value = scanner.nextInt();
        while (value != -1) {
            karyHeap.insert(value);
            value = scanner.nextInt();
        }

        System.out.println("Heap after insertion:");
        karyHeap.printHeap();

        System.out.println("Extracting maximum element from heap:");
        int max = karyHeap.extractMax();
        System.out.println("Maximum element extracted: " + max);

        System.out.println("Heap after extraction:");
        karyHeap.printHeap();

        scanner.close();
    }
}
Sample Input:
Enter the capacity of the heap: 8
Enter the value of k for K-ary heap: 3
Enter elements to insert into the K-ary heap (enter -1 to stop):
12
7
15
10
9
3
17
4
-1

BFS
import java.util.*;

class BFS {
    private int V; // Number of vertices
    private LinkedList<Integer> adj[]; // Adjacency list representation

    // Constructor
    BFS(int v) {
        V = v;
        adj = new LinkedList[v];
        for (int i = 0; i < v; ++i)
            adj[i] = new LinkedList();
    }

    // Function to add an edge into the graph
    void addEdge(int v, int w) {
        adj[v].add(w);
    }

    // Function to perform BFS traversal from a given source vertex
    void bfs(int s) {
        // Mark all the vertices as not visited
        boolean visited[] = new boolean[V];

        // Create a queue for BFS
        LinkedList<Integer> queue = new LinkedList<Integer>();

        // Mark the current node as visited and enqueue it
        visited[s] = true;
        queue.add(s);

        while (queue.size() != 0) {
            // Dequeue a vertex from queue and print it
            s = queue.poll();
            System.out.print(s + " ");

            // Get all adjacent vertices of the dequeued vertex s. If an adjacent has not been visited, then mark it visited and enqueue it
            Iterator<Integer> i = adj[s].listIterator();
            while (i.hasNext()) {
                int n = i.next();
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of vertices: ");
        int V = scanner.nextInt();
        BFS graph = new BFS(V);

        System.out.print("Enter the number of edges: ");
        int E = scanner.nextInt();

        System.out.println("Enter the edges (source destination):");
        for (int i = 0; i < E; ++i) {
            int source = scanner.nextInt();
            int destination = scanner.nextInt();
            graph.addEdge(source, destination);
        }

        System.out.print("Enter the source vertex for BFS: ");
        int sourceVertex = scanner.nextInt();

        System.out.println("BFS traversal starting from vertex " + sourceVertex + ":");
        graph.bfs(sourceVertex);

        scanner.close();
    }
}
Sample Input:
Enter the number of vertices: 6
Enter the number of edges: 8
Enter the edges (source destination):
0 1
0 2
1 3
1 4
2 4
3 4
3 5
4 5
Enter the source vertex for BFS: 0
DFS
import java.util.*;

class DFS {
    private int V; // Number of vertices
    private LinkedList<Integer> adj[]; // Adjacency list representation

    // Constructor
    DFS(int v) {
        V = v;
        adj = new LinkedList[v];
        for (int i = 0; i < v; ++i)
            adj[i] = new LinkedList();
    }

    // Function to add an edge into the graph
    void addEdge(int v, int w) {
        adj[v].add(w);
    }

    // Function to perform DFS traversal from a given source vertex
    void dfsUtil(int v, boolean visited[]) {
        // Mark the current node as visited and print it
        visited[v] = true;
        System.out.print(v + " ");

        // Recur for all the vertices adjacent to this vertex
        Iterator<Integer> i = adj[v].listIterator();
        while (i.hasNext()) {
            int n = i.next();
            if (!visited[n])
                dfsUtil(n, visited);
        }
    }

    // Function to perform DFS traversal starting from a given source vertex
    void dfs(int v) {
        // Mark all the vertices as not visited(set as false by default in java)
        boolean visited[] = new boolean[V];

        // Call the recursive helper function to print DFS traversal
        dfsUtil(v, visited);
    }

    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the number of vertices: ");
        int V = scanner.nextInt();
        DFS graph = new DFS(V);

        System.out.print("Enter the number of edges: ");
        int E = scanner.nextInt();

        System.out.println("Enter the edges (source destination):");
        for (int i = 0; i < E; ++i) {
            int source = scanner.nextInt();
            int destination = scanner.nextInt();
            graph.addEdge(source, destination);
        }

        System.out.print("Enter the source vertex for DFS: ");
        int sourceVertex = scanner.nextInt();

        System.out.println("DFS traversal starting from vertex " + sourceVertex + ":");
        graph.dfs(sourceVertex);

        scanner.close();
    }
}
Sample Input:

Enter the number of vertices: 6
Enter the number of edges: 7
Enter the edges (source destination):
0 1
0 2
1 3
1 4
2 4
3 5
4 5
Enter the source vertex for DFS: 0
Recover BST
import java.util.Scanner;

class TreeNode {
    int val;
    TreeNode left, right;

    TreeNode(int val) {
        this.val = val;
        left = right = null;
    }
}

public class RecoverBST {
    TreeNode firstElement = null;
    TreeNode secondElement = null;
    TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);

    public void recoverTree(TreeNode root) {
        // Traverse the tree and identify the swapped nodes
        traverse(root);

        // Swap the values of the two identified nodes
        int temp = firstElement.val;
        firstElement.val = secondElement.val;
        secondElement.val = temp;
    }

    private void traverse(TreeNode root) {
        if (root == null)
            return;

        // In-order traversal
        traverse(root.left);

        // Check for the swapped nodes
        if (firstElement == null && root.val < prevElement.val) {
            firstElement = prevElement;
        }
        if (firstElement != null && root.val < prevElement.val) {
            secondElement = root;
        }
        prevElement = root;

        traverse(root.right);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Construct the BST from user input
        System.out.println("Enter the root value of the BST:");
        int rootVal = scanner.nextInt();
        TreeNode root = new TreeNode(rootVal);
        constructBST(root, scanner);

        // Recover the BST
        RecoverBST recoverBST = new RecoverBST();
        recoverBST.recoverTree(root);

        // Print the recovered tree
        System.out.println("Recovered Tree:");
        printInOrder(root);

        scanner.close();
    }

    private static void constructBST(TreeNode root, Scanner scanner) {
        System.out.println("Enter left child for node " + root.val + " (Enter -1 if no left child):");
        int leftVal = scanner.nextInt();
        if (leftVal != -1) {
            root.left = new TreeNode(leftVal);
            constructBST(root.left, scanner);
        }

        System.out.println("Enter right child for node " + root.val + " (Enter -1 if no right child):");
        int rightVal = scanner.nextInt();
        if (rightVal != -1) {
            root.right = new TreeNode(rightVal);
            constructBST(root.right, scanner);
        }
    }

    private static void printInOrder(TreeNode root) {
        if (root == null)
            return;
        printInOrder(root.left);
        System.out.print(root.val + " ");
        printInOrder(root.right);
    }
}
Sample Input:
Enter the root value of the BST:
3
Enter left child for node 3 (Enter -1 if no left child):
1
Enter right child for node 3 (Enter -1 if no right child):
4
Enter left child for node 1 (Enter -1 if no left child):
-1
Enter right child for node 1 (Enter -1 if no right child):
-1
Enter left child for node 4 (Enter -1 if no left child):
2
Enter right child for node 4 (Enter -1 if no right child):
-1
Enter left child for node 2 (Enter -1 if no left child):
-1
Enter right child for node 2 (Enter -1 if no right child):
-1


View Of TREE( Right & Left)
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;

    TreeNode(int val) {
        this.val = val;
        left = right = null;
    }
}

class TreeView {
    public static void leftView(TreeNode root) {
        if (root == null)
            return;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode current = queue.poll();
                if (i == 0) {
                    System.out.print(current.val + " ");
                }
                if (current.left != null) {
                    queue.offer(current.left);
                }
                if (current.right != null) {
                    queue.offer(current.right);
                }
            }
        }
    }

    public static void rightView(TreeNode root) {
        if (root == null)
            return;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode current = queue.poll();
                if (i == size - 1) {
                    System.out.print(current.val + " ");
                }
                if (current.left != null) {
                    queue.offer(current.left);
                }
                if (current.right != null) {
                    queue.offer(current.right);
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Construct the binary tree from user input
        System.out.println("Enter the root value of the tree:");
        int rootVal = scanner.nextInt();
        TreeNode root = new TreeNode(rootVal);
        constructTree(root, scanner);

        // Print the views of the tree
        System.out.println("Left View of the Tree:");
        leftView(root);

        System.out.println("\nRight View of the Tree:");
        rightView(root);

        scanner.close();
    }

    private static void constructTree(TreeNode root, Scanner scanner) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode current = queue.poll();

            System.out.println("Enter left child for node " + current.val + " (Enter -1 if no left child):");
            int leftVal = scanner.nextInt();
            if (leftVal != -1) {
                current.left = new TreeNode(leftVal);
                queue.offer(current.left);
            }

            System.out.println("Enter right child for node " + current.val + " (Enter -1 if no right child):");
            int rightVal = scanner.nextInt();
            if (rightVal != -1) {
                current.right = new TreeNode(rightVal);
                queue.offer(current.right);
            }
        }
    }
}
Sample:
Enter the root value of the tree:
1
Enter left child for node 1 (Enter -1 if no left child):
2
Enter right child for node 1 (Enter -1 if no right child):
3
Enter left child for node 2 (Enter -1 if no left child):
4
Enter right child for node 2 (Enter -1 if no right child):
-1
Enter left child for node 3 (Enter -1 if no left child):
-1
Enter right child for node 3 (Enter -1 if no right child):
5
Enter left child for node 4 (Enter -1 if no left child):
-1
Enter right child for node 4 (Enter -1 if no right child):
-1
Enter left child for node 5 (Enter -1 if no left child):
-1
Enter right child for node 5 (Enter -1 if no right child):
-1
Dialâ€™s ALGORITHM 
import java.util.*;

class DijkstraAlgorithm {
    static class Edge {
        int destination;
        int weight;

        Edge(int destination, int weight) {
            this.destination = destination;
            this.weight = weight;
        }
    }

    static class Graph {
        int vertices;
        List<List<Edge>> adjacencyList;

        Graph(int vertices) {
            this.vertices = vertices;
            adjacencyList = new ArrayList<>(vertices);
            for (int i = 0; i < vertices; i++) {
                adjacencyList.add(new ArrayList<>());
            }
        }

        void addEdge(int source, int destination, int weight) {
            adjacencyList.get(source).add(new Edge(destination, weight));
        }

        void dijkstra(int source) {
            PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(Comparator.comparingInt(a -> a.weight));
            int[] distance = new int[vertices];
            Arrays.fill(distance, Integer.MAX_VALUE);
            distance[source] = 0;

            priorityQueue.offer(new Edge(source, 0));

            while (!priorityQueue.isEmpty()) {
                Edge current = priorityQueue.poll();
                int currentVertex = current.destination;

                for (Edge neighbor : adjacencyList.get(currentVertex)) {
                    int newDistance = distance[currentVertex] + neighbor.weight;
                    if (newDistance < distance[neighbor.destination]) {
                        distance[neighbor.destination] = newDistance;
                        priorityQueue.offer(new Edge(neighbor.destination, newDistance));
                    }
                }
            }

            System.out.println("Shortest distances from source node " + source + ":");
            for (int i = 0; i < vertices; i++) {
                if (distance[i] != Integer.MAX_VALUE) {
                    System.out.println("Node " + i + ": " + distance[i]);
                } else {
                    System.out.println("Node " + i + ": Infinity");
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get the number of vertices and edges
        System.out.println("Enter the number of vertices:");
        int vertices = scanner.nextInt();
        System.out.println("Enter the number of edges:");
        int edges = scanner.nextInt();

        // Create a graph
        Graph graph = new Graph(vertices);

        // Add edges to the graph
        System.out.println("Enter the edges in the format (source destination weight):");
        for (int i = 0; i < edges; i++) {
            int source = scanner.nextInt();
            int destination = scanner.nextInt();
            int weight = scanner.nextInt();
            graph.addEdge(source, destination, weight);
        }

        // Get the source node
        System.out.println("Enter the source node:");
        int source = scanner.nextInt();

        // Run Dijkstra's algorithm
        graph.dijkstra(source);

        scanner.close();
    }
}
Sample INPUT:
Enter the number of vertices:
6
Enter the number of edges:
9
Enter the edges in the format (source destination weight):
0 1 4
0 2 2
1 2 5
1 3 10
2 3 3
2 4 2
2 5 8
3 4 6
4 5 1
Enter the source node:
0
Bellman Ford Algorithm
import java.util.*;

class BellmanFordAlgorithm {
    static class Edge {
        int source, destination, weight;

        Edge(int source, int destination, int weight) {
            this.source = source;
            this.destination = destination;
            this.weight = weight;
        }
    }

    static class Graph {
        int vertices, edges;
        List<Edge> edgeList;

        Graph(int vertices, int edges) {
            this.vertices = vertices;
            this.edges = edges;
            edgeList = new ArrayList<>();
        }

        void addEdge(int source, int destination, int weight) {
            edgeList.add(new Edge(source, destination, weight));
        }

        void bellmanFord(int source) {
            int[] distance = new int[vertices];
            Arrays.fill(distance, Integer.MAX_VALUE);
            distance[source] = 0;

            // Relax all edges (vertices - 1) times
            for (int i = 0; i < vertices - 1; i++) {
                for (Edge edge : edgeList) {
                    if (distance[edge.source] != Integer.MAX_VALUE && distance[edge.source] + edge.weight < distance[edge.destination]) {
                        distance[edge.destination] = distance[edge.source] + edge.weight;
                    }
                }
            }

            // Check for negative weight cycles
            for (Edge edge : edgeList) {
                if (distance[edge.source] != Integer.MAX_VALUE && distance[edge.source] + edge.weight < distance[edge.destination]) {
                    System.out.println("Graph contains negative weight cycle");
                    return;
                }
            }

            // Print the shortest distances from the source
            System.out.println("Shortest distances from source node " + source + ":");
            for (int i = 0; i < vertices; i++) {
                if (distance[i] != Integer.MAX_VALUE) {
                    System.out.println("Node " + i + ": " + distance[i]);
                } else {
                    System.out.println("Node " + i + ": Infinity");
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get the number of vertices and edges
        System.out.println("Enter the number of vertices:");
        int vertices = scanner.nextInt();
        System.out.println("Enter the number of edges:");
        int edges = scanner.nextInt();

        // Create a graph
        Graph graph = new Graph(vertices, edges);

        // Add edges to the graph
        System.out.println("Enter the edges in the format (source destination weight):");
        for (int i = 0; i < edges; i++) {
            int source = scanner.nextInt();
            int destination = scanner.nextInt();
            int weight = scanner.nextInt();
            graph.addEdge(source, destination, weight);
        }

        // Get the source node
        System.out.println("Enter the source node:");
        int source = scanner.nextInt();

        // Run Bellman-Ford algorithm
        graph.bellmanFord(source);

        scanner.close();
    }
}
Sample INPUT
Enter the number of vertices:
5
Enter the number of edges:
8
Enter the edges in the format (source destination weight):
0 1 -1
0 2 4
1 2 3
1 3 2
1 4 2
3 2 5
3 1 1
4 3 -3
Enter the source node:
0
Topological Sort
import java.util.*;

class TopologicalSort {
    static class Graph {
        private final int vertices;
        private final List<List<Integer>> adjacencyList;

        Graph(int vertices) {
            this.vertices = vertices;
            adjacencyList = new ArrayList<>(vertices);
            for (int i = 0; i < vertices; i++) {
                adjacencyList.add(new ArrayList<>());
            }
        }

        void addEdge(int source, int destination) {
            adjacencyList.get(source).add(destination);
        }

        void topologicalSortUtil(int vertex, boolean[] visited, Stack<Integer> stack) {
            visited[vertex] = true;

            for (Integer adjacentVertex : adjacencyList.get(vertex)) {
                if (!visited[adjacentVertex]) {
                    topologicalSortUtil(adjacentVertex, visited, stack);
                }
            }

            stack.push(vertex);
        }

        void topologicalSort() {
            Stack<Integer> stack = new Stack<>();
            boolean[] visited = new boolean[vertices];

            for (int i = 0; i < vertices; i++) {
                if (!visited[i]) {
                    topologicalSortUtil(i, visited, stack);
                }
            }

            System.out.println("Topological order:");
            while (!stack.isEmpty()) {
                System.out.print(stack.pop() + " ");
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get the number of vertices and edges
        System.out.println("Enter the number of vertices:");
        int vertices = scanner.nextInt();
        System.out.println("Enter the number of edges:");
        int edges = scanner.nextInt();

        // Create a graph
        Graph graph = new Graph(vertices);

        // Add edges to the graph
        System.out.println("Enter the edges in the format (source destination):");
        for (int i = 0; i < edges; i++) {
            int source = scanner.nextInt();
            int destination = scanner.nextInt();
            graph.addEdge(source, destination);
        }

        // Perform topological sorting
        graph.topologicalSort();

        scanner.close();
    }
}
Sample INPUT
Enter the number of vertices:
6
Enter the number of edges:
6
Enter the edges in the format (source destination):
5 2
5 0
4 0
4 1
2 3
3 1
Binomial Heap
import java.util.*;

class BinomialHeap {
    static class Node {
        int key, degree;
        Node parent, child, sibling;

        Node(int key) {
            this.key = key;
            this.degree = 0;
            this.parent = null;
            this.child = null;
            this.sibling = null;
        }
    }

    static class BinomialHeapImpl {
        Node head;

        BinomialHeapImpl() {
            head = null;
        }

        // Merge two binomial heaps
        private Node mergeHeaps(Node h1, Node h2) {
            if (h1 == null)
                return h2;
            if (h2 == null)
                return h1;

            Node res = null;
            Node tail = null;
            Node p1 = h1;
            Node p2 = h2;

            while (p1 != null && p2 != null) {
                if (p1.degree <= p2.degree) {
                    if (tail == null) {
                        tail = p1;
                        res = p1;
                    } else {
                        tail.sibling = p1;
                        tail = p1;
                    }
                    p1 = p1.sibling;
                } else {
                    if (tail == null) {
                        tail = p2;
                        res = p2;
                    } else {
                        tail.sibling = p2;
                        tail = p2;
                    }
                    p2 = p2.sibling;
                }
            }

            if (p1 != null)
                tail.sibling = p1;
            else
                tail.sibling = p2;

            return res;
        }

        // Union two binomial heaps
        private Node union(Node h1, Node h2) {
            if (h1 == null && h2 == null)
                return null;
            else if (h1 == null)
                return h2;
            else if (h2 == null)
                return h1;

            Node res = mergeHeaps(h1, h2);
            Node prevX = null;
            Node x = res;
            Node nextX = x.sibling;

            while (nextX != null) {
                if (x.degree != nextX.degree || (nextX.sibling != null && nextX.sibling.degree == x.degree)) {
                    prevX = x;
                    x = nextX;
                } else {
                    if (x.key <= nextX.key) {
                        x.sibling = nextX.sibling;
                        link(nextX, x);
                    } else {
                        if (prevX == null)
                            res = nextX;
                        else
                            prevX.sibling = nextX;
                        link(x, nextX);
                        x = nextX;
                    }
                }
                nextX = x.sibling;
            }

            return res;
        }

        // Link two binomial trees
        private void link(Node x, Node y) {
            x.parent = y;
            x.sibling = y.child;
            y.child = x;
            y.degree++;
        }

        // Insert a key into the binomial heap
        public void insert(int key) {
            Node newNode = new Node(key);
            head = union(head, newNode);
        }

        // Find the minimum key in the binomial heap
        public int findMinimum() {
            if (head == null)
                return Integer.MIN_VALUE;

            Node minNode = head;
            int minVal = head.key;
            Node current = head.sibling;

            while (current != null) {
                if (current.key < minVal) {
                    minNode = current;
                    minVal = current.key;
                }
                current = current.sibling;
            }

            return minVal;
        }

        // Extract the minimum key from the binomial heap
        public int extractMin() {
            if (head == null)
                return Integer.MIN_VALUE;

            Node prevMin = null;
            Node min = head;
            Node prev = null;
            Node current = head.sibling;
            Node next = head;

            while (next != null) {
                if (next.key < min.key) {
                    min = next;
                    prevMin = prev;
                }
                prev = next;
                next = next.sibling;
            }

            if (prevMin == null)
                head = min.sibling;
            else
                prevMin.sibling = min.sibling;

            // Reverse the order of the children of the minimum node
            Node child = min.child;
            Node prevChild = null;
            Node nextChild = null;

            while (child != null) {
                nextChild = child.sibling;
                child.sibling = prevChild;
                child.parent = null;
                prevChild = child;
                child = nextChild;
            }

            head = union(head, prevChild);

            return min.key;
        }

        // Print the binomial heap
        public void printHeap() {
            if (head == null)
                return;

            Queue<Node> queue = new LinkedList<>();
            queue.offer(head);

            while (!queue.isEmpty()) {
                Node current = queue.poll();
                System.out.print(current.key + " ");

                if (current.child != null) {
                    Node child = current.child;
                    while (child != null) {
                        queue.offer(child);
                        child = child.sibling;
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        BinomialHeapImpl binomialHeap = new BinomialHeapImpl();

        while (true) {
            System.out.println("\n1. Insert key");
            System.out.println("2. Find minimum key");
            System.out.println("3. Extract minimum key");
            System.out.println("4. Print heap");
            System.out.println("5. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter key to insert: ");
                    int key = scanner.nextInt();
                    binomialHeap.insert(key);
                    break;
                case 2:
                    int min = binomialHeap.findMinimum();
                    if (min == Integer.MIN_VALUE)
                        System.out.println("Heap is empty");
                    else
                        System.out.println("Minimum key: " + min);
                    break;
                case 3:
                    int extractedMin = binomialHeap.extractMin();
                    if (extractedMin == Integer.MIN_VALUE)
                        System.out.println("Heap is empty");
                    else
                        System.out.println("Extracted minimum key: " + extractedMin);
                    break;
                case 4:
                    System.out.print("Heap: ");
                    binomialHeap.printHeap();
                    System.out.println();
                    break;
                case 5:
                    scanner.close();
                    System.exit(0);
                default:
                    System.out.println("Invalid choice");
            }
        }
    }
}
Sample INPUT
1. Insert key
2. Find minimum key
3. Extract minimum key
4. Print heap
5. Exit
Enter your choice: 1
Enter key to insert: 8

1. Insert key
2. Find minimum key
3. Extract minimum key
4. Print heap
5. Exit
Enter your choice: 1
Enter key to insert: 4

1. Insert key
2. Find minimum key
3. Extract minimum key
4. Print heap
5. Exit
Enter your choice: 1
Enter key to insert: 10

1. Insert key
2. Find minimum key
3. Extract minimum key
4. Print heap
5. Exit
Enter your choice: 4
Heap: 4 8 10

1. Insert key
2. Find minimum key
3. Extract minimum key
4. Print heap
5. Exit
Enter your choice: 2
Minimum key: 4

1. Insert key
2. Find minimum key
3. Extract minimum key
4. Print heap
5. Exit
Enter your choice: 3
Extracted minimum key: 4

1. Insert key
2. Find minimum key
3. Extract minimum key
4. Print heap
5. Exit
Enter your choice: 4
Heap: 8 10

1. Insert key
2. Find minimum key
3. Extract minimum key
4. Print heap
5. Exit
Enter your choice: 5
Wiiner Tree
import java.util.*;

class Node {
    int idx;
    Node left, right;
}

public class Main {

    static Node createNode(int idx) {
        Node t = new Node();
        t.left = t.right = null;
        t.idx = idx;
        return t;
    }

    static void traverseHeight(Node root, int[] arr, int[] res) {
        if (root == null || (root.left == null && root.right == null))
            return;
        if (res[0] > arr[root.left.idx] && root.left.idx != root.idx) {
            res[0] = arr[root.left.idx];
            traverseHeight(root.right, arr, res);
        } else if (res[0] > arr[root.right.idx] && root.right.idx != root.idx) {
            res[0] = arr[root.right.idx];
            traverseHeight(root.left, arr, res);
        }
    }

    static void findSecondMin(int[] arr, int n) {
        List<Node> li = new LinkedList<>();
        Node root = null;
        for (int i = 0; i < n; i += 2) {
            Node t1 = createNode(i);
            Node t2 = null;
            if (i + 1 < n) {
                t2 = createNode(i + 1);
                root = (arr[i] < arr[i + 1]) ? createNode(i) : createNode(i + 1);
                root.left = t1;
                root.right = t2;
                li.add(root);
            } else
                li.add(t1);
        }
        int lsize = li.size();
        while (lsize != 1) {
            int last = (lsize & 1) == 1 ? lsize - 2 : lsize - 1;
            for (int i = 0; i < last; i += 2) {
                Node f1 = li.remove(0);
                Node f2 = li.remove(0);
                root = (arr[f1.idx] < arr[f2.idx]) ? createNode(f1.idx) : createNode(f2.idx);
                root.left = f1;
                root.right = f2;
                li.add(root);
            }
            if ((lsize & 1) == 1) {
                li.add(li.get(0));
                li.remove(0);
            }
            lsize = li.size();
        }

        int[] res = { Integer.MAX_VALUE };
        traverseHeight(root, arr, res);
        System.out.println("Minimum: " + arr[root.idx] + ", Second minimum: " + res[0]);
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        System.out.print("Enter the number of elements: ");
        int n = s.nextInt();
        int arr[] = new int[n];
        System.out.println("Enter the elements:");
        for (int i = 0; i < n; i++)
            arr[i] = s.nextInt();
        findSecondMin(arr, n);
        s.close();
    }
}
